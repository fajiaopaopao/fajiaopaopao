{"pages":[{"title":"","text":"关于我前端，现居北京 努力提高自己的姿势水平中~","link":"/about/index.html"}],"posts":[{"title":"H5图片上传踩坑记录","text":"最近写的一个项目中图片上传这个功能，运营同学反馈用户上传的图片出现了照片内容变黑错乱、上传照片大小为0字节等奇怪问题，下面就记录下处理问题的过程。 前言我们常用H5上传图片方式，有以下几种： 利用 input 和 form 表单进行文件上传，但是无法对图片进行压缩、旋转等优化处理。 利用RenderFile的readAsDataURL转成base64进行上传，但是base64编码通常比所对应的图片二进制文件体积要更大，同时不支持切片上传。 利用RenderFile或者 URL.createObjectURL将File对象转换为Blob，再利用canvas进行图片压缩、剪裁。最后转换为blob插入到FormData中传递给后端服务。 实际项目中我选择的是最后一种来实现文件上传： type类型为file 的input标签可以选择设备上的文件进行一个或者多个进行上传操作，具体属性可阅读MDN-input 12345678&lt;input type=&quot;file&quot; ref=&quot;input&quot; :name=&quot;fileKey&quot; capture=&quot;camera&quot; accept=&quot;image/*&quot; @change=&quot;someHander&quot;/&gt; 坑点一：选择相同文件不触发input 的onchange事件因为两次选择的文件一致，input的value值并没有发生改变，所以不会触发change事件，所以得到文件后清空value来避免这个问题。 12345function someHander(event) { const file = e.target.files[0]; // some action event.target.value = '';} 坑点二：对得到File对象进行处理目前对FIle对象处理常用的API有 URL.createObjectURL：参数传递file或者blob对象，返回一个新的URL对象 执行方式：同步函数立即执行 内存消耗：因为URL的生命周期和document相关，只有在窗口关闭、执行URL.revokeObjectURL时销毁，所以不适用后应该主动去销毁改URL 对象 兼容性：IE10后的所有现代浏览器 FileReader. readAsDataURL: 参数传递file或者blob对象，返回所对应Base64内容 执行方式：FileRender利用自身的load、error进行异步执行，需要绑定对应的事件得到执行的结果。 内存消耗：因为Base64包含的都是文本内容，相对于blob占据更多的内存空间，但是存储base64的变量在不使用之后会被JavaScript的垃圾回收机制，自动回收。 兼容性：IE10后的所有现代浏览器 所以综上所述，这里选择URL.createObjectURL进行File对象的读取。 12345const blob = URL.createObjectURL(file);let imgEl = new Image();imgEl.src = blob;// some action....URL.revokeObjectURL(blob); // 记得释放URL对象 坑点三：图片方向旋转问题在IOS设备拍照中，会出现照片在canvas绘制出现是横的，和手持拍照时的方向并不一致。为了解决这个问题，我们可以获取exif中一个Orientation的参数，得到照片旋转方向。详见可以阅读七牛云-关于图片 EXIF 信息中旋转参数 Orientation 的理解 可以利用开源的exif-js插件得到照片的exif信息，从而在canva绘制正确展示的图片。 坑点四：canvas最大尺寸渲染利用canvas绘制图片，应该控制下控制绘制的尺寸大小，因为绘制也是占用内存的嘛。太大的尺寸的图片绘制效率不高不说，低端的手机可能会导致浏览器直接奔溃、卡顿等问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950resizeImg(img: HTMLImageElement, orientation) { const { width, height } = img; let ret = { width, height }; if (&quot;68&quot;.indexOf(orientation) &gt; -1) { // 90、270度宽高互换 ret = { width: height, height: width }; } // 如果原图小于设定，采用原图 if ( ret.width &lt; this.options.maxWidth || ret.height &lt; this.options.maxHeight ) { return ret; } const scale = ret.width / ret.height; // 基于宽高的比例进行scale if (width &amp;&amp; height) { if (scale &gt;= width / height) { if (ret.width &gt; width) { ret.width = width; ret.height = Math.ceil(width / scale); } } else { if (ret.height &gt; height) { ret.height = height; ret.width = Math.ceil(height * scale); } } } else if (width) { if (width &lt; ret.width) { ret.width = width; ret.height = Math.ceil(width / scale); } } else if (height) { if (height &lt; ret.height) { ret.width = Math.ceil(height * scale); ret.height = height; } } // 超过这个值base64无法生成，在IOS上 while (ret.width &gt;= 3264 || ret.height &gt;= 2448) { ret.width *= 0.8; ret.height *= 0.8; } return ret; } 坑点五：某些webkit版本和微信X5内核 toDataURL解析问题在上述环境中，照片压缩会导致图片变黑、错乱、重复排列问题，如图： Ps: 原因是因为在使用toDataURL(jpeg, 0.5)压缩时，内核使用了png解析算法，在这些机型下需要引用jpeg解析函数去自行解析。 坑点六：Formdata中 appendblob为空这个问题这里就不展开说明了，可以参考[Blob in FormData is null了解解决方案。 总结以上为遇到几个主要的问题，可能还有没有触及到的其他问题，将会再遇到后继续编辑。","link":"/2019/01/06/H5%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"}],"categories":[{"name":"笔记本","slug":"笔记本","link":"/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"}]}