{"pages":[{"title":"","text":"404 html{font-size:62.5%;box-sizing:border-box}*,::after,::before{box-sizing:inherit}body{font-family:sf pro text,sf pro icons,helvetica neue,helvetica,arial,sans-serif;font-size:1.6rem;line-height:1.65;word-break:break-word;font-kerning:auto;font-variant:normal;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-rendering:optimizeLegibility;hyphens:auto;height:100vh;max-height:100vh;margin:0}::selection{background:#79ffe1}::-moz-selection{background:#79ffe1}a{cursor:pointer;color:#0070f3;text-decoration:none;transition:all .2s ease;border-bottom:1px solid #0000}a:hover{border-bottom:1px solid #0070f3}ul{padding:0;margin-left:1.5em;list-style-type:none}li{margin-bottom:10px}ul li:before{content:'\\02013'}li:before{display:inline-block;color:#ccc;position:absolute;margin-left:-18px;transition:color .2s ease}code{font-family:Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,serif;font-size:.92em}code:after,code:before{content:'`'}.container{display:flex;justify-content:center;flex-direction:column;min-height:100vh}main{max-width:80rem;padding:4rem 6rem;margin:auto}ul{margin-bottom:32px}.error-title{font-size:2rem;border-left:2px solid #ff0080;padding-left:22px;line-height:1.5;margin-bottom:24px;font-weight:500}main p{color:#333}.devinfo-container{ width: 100%; border:1px solid #ddd;border-radius:4px;padding:2rem;display:flex;flex-direction:column;margin-bottom:32px}.error-code{margin:0;font-size:1.6rem;color:#000;margin-bottom:1.6rem}.devinfo-line{color:#333}.devinfo-line code,code,li{color:#000}.devinfo-line:not(:last-child){margin-bottom:8px}.docs-link,.contact-link{font-weight:500}header,footer,footer a{display:flex;justify-content:center;align-items:center}header,footer{min-height:100px;height:100px}header{border-bottom:1px solid #eaeaea}header h1{font-size:1.8rem;margin:0;font-weight:500}header p{font-size:1.3rem;margin:0;font-weight:500}.header-item{display:flex;padding:0 2rem;margin:2rem 0;text-decoration:line-through;color:#999}.header-item.active{color:#ff0080;text-decoration:none}.header-item.first{border-right:1px solid #eaeaea}.header-item-content{display:flex;flex-direction:column}.header-item-icon{margin-right:1rem;margin-top:.6rem}footer{border-top:1px solid #eaeaea}footer a{color:#000}footer a:hover{border-bottom-color:#0000}footer svg{margin-left:.8rem}.note{padding:8pt 16pt;border-radius:5px;border:1px solid #0070f3;font-size:14px;line-height:1.8;color:#0070f3}.note__type{text-transform:uppercase;font-weight:500}@media(max-width:500px){.devinfo-container .devinfo-line code{margin-top:.4rem}.devinfo-container .devinfo-line:not(:last-child){margin-bottom:1.6rem}.devinfo-container{margin-bottom:0}header{flex-direction:column;height:auto;min-height:auto;align-items:flex-start}.header-item.first{border-right:none;margin-bottom:0}main{padding:1rem 2rem}body{font-size:1.4rem;line-height:1.55}footer{display:none}.note{margin-top:16px}} 404: NOT_FOUND Code: NOT_FOUND Back Home: www.ifajiao.com","link":"/404.html"},{"title":"","text":"关于我前端，现居北京 努力提高自己的姿势水平中~","link":"/about/index.html"}],"posts":[{"title":"H5图片上传踩坑记录","text":"最近写的一个项目中图片上传这个功能，运营同学反馈用户上传的图片出现了照片内容变黑错乱、上传照片大小为0字节等奇怪问题，下面就记录下处理问题的过程。 前言我们常用H5上传图片方式，有以下几种： 利用 input 和 form 表单进行文件上传，但是无法对图片进行压缩、旋转等优化处理。 利用RenderFile的readAsDataURL转成base64进行上传，但是base64编码通常比所对应的图片二进制文件体积要更大，同时不支持切片上传。 利用RenderFile或者 URL.createObjectURL将File对象转换为Blob，再利用canvas进行图片压缩、剪裁。最后转换为blob插入到FormData中传递给后端服务。 实际项目中我选择的是最后一种来实现文件上传： type类型为file 的input标签可以选择设备上的文件进行一个或者多个进行上传操作，具体属性可阅读MDN-input 12345678&lt;input type=&quot;file&quot; ref=&quot;input&quot; :name=&quot;fileKey&quot; capture=&quot;camera&quot; accept=&quot;image/*&quot; @change=&quot;someHander&quot;/&gt; 坑点一：选择相同文件不触发input 的onchange事件因为两次选择的文件一致，input的value值并没有发生改变，所以不会触发change事件，所以得到文件后清空value来避免这个问题。 12345function someHander(event) { const file = e.target.files[0]; // some action event.target.value = '';} 坑点二：对得到File对象进行处理目前对FIle对象处理常用的API有 URL.createObjectURL：参数传递file或者blob对象，返回一个新的URL对象 执行方式：同步函数立即执行 内存消耗：因为URL的生命周期和document相关，只有在窗口关闭、执行URL.revokeObjectURL时销毁，所以不适用后应该主动去销毁改URL 对象 兼容性：IE10后的所有现代浏览器 FileReader. readAsDataURL: 参数传递file或者blob对象，返回所对应Base64内容 执行方式：FileRender利用自身的load、error进行异步执行，需要绑定对应的事件得到执行的结果。 内存消耗：因为Base64包含的都是文本内容，相对于blob占据更多的内存空间，但是存储base64的变量在不使用之后会被JavaScript的垃圾回收机制，自动回收。 兼容性：IE10后的所有现代浏览器 所以综上所述，这里选择URL.createObjectURL进行File对象的读取。 12345const blob = URL.createObjectURL(file);let imgEl = new Image();imgEl.src = blob;// some action....URL.revokeObjectURL(blob); // 记得释放URL对象 坑点三：图片方向旋转问题在IOS设备拍照中，会出现照片在canvas绘制出现是横的，和手持拍照时的方向并不一致。为了解决这个问题，我们可以获取exif中一个Orientation的参数，得到照片旋转方向。详见可以阅读七牛云-关于图片 EXIF 信息中旋转参数 Orientation 的理解 可以利用开源的exif-js插件得到照片的exif信息，从而在canva绘制正确展示的图片。 坑点四：canvas最大尺寸渲染利用canvas绘制图片，应该控制下控制绘制的尺寸大小，因为绘制也是占用内存的嘛。太大的尺寸的图片绘制效率不高不说，低端的手机可能会导致浏览器直接奔溃、卡顿等问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950resizeImg(img: HTMLImageElement, orientation) { const { width, height } = img; let ret = { width, height }; if (&quot;68&quot;.indexOf(orientation) &gt; -1) { // 90、270度宽高互换 ret = { width: height, height: width }; } // 如果原图小于设定，采用原图 if ( ret.width &lt; this.options.maxWidth || ret.height &lt; this.options.maxHeight ) { return ret; } const scale = ret.width / ret.height; // 基于宽高的比例进行scale if (width &amp;&amp; height) { if (scale &gt;= width / height) { if (ret.width &gt; width) { ret.width = width; ret.height = Math.ceil(width / scale); } } else { if (ret.height &gt; height) { ret.height = height; ret.width = Math.ceil(height * scale); } } } else if (width) { if (width &lt; ret.width) { ret.width = width; ret.height = Math.ceil(width / scale); } } else if (height) { if (height &lt; ret.height) { ret.width = Math.ceil(height * scale); ret.height = height; } } // 超过这个值base64无法生成，在IOS上 while (ret.width &gt;= 3264 || ret.height &gt;= 2448) { ret.width *= 0.8; ret.height *= 0.8; } return ret; } 坑点五：某些webkit版本和微信X5内核 toDataURL解析问题在上述环境中，照片压缩会导致图片变黑、错乱、重复排列问题，如图： Ps: 原因是因为在使用toDataURL(jpeg, 0.5)压缩时，内核使用了png解析算法，在这些机型下需要引用jpeg解析函数去自行解析。 坑点六：Formdata中 appendblob为空这个问题这里就不展开说明了，可以参考[Blob in FormData is null了解解决方案。 总结以上为遇到几个主要的问题，可能还有没有触及到的其他问题，将会再遇到后继续编辑。","link":"/frontend-upload-problem-note/"},{"title":"技嘉Z370 HD3P + i7-8700K + Vega56 黑苹果OpenCore EFI分享","text":"之前折腾的Catalina正常运行了大概快一年左右时间了，作为日常生产力机器使用没什么问题，但随着最近BigSur正式版的推出，又尝试跟进升级下我的黑苹果，使用了一个礼拜，暂时没发现问题，借此把我用的EFI做个分享吧。 使用版本 macOS 11.0.1 硬件配置 规格 详情 主板 技嘉 Z370 HD3P CPU Intel Core i7-8700K 核显 Intel UHD Graphics 630 独显 RX VEGA56 8G HBM2 超白金 OC 内存卡 海盗船复仇者 DDR4 3200 8G*2 SSD1 英睿达 BX500 480G =&gt; Windows + EFI SSD2 西部数据 Black系统 250GB =&gt; MacOS HDD 希捷 酷鱼系列 2TB =&gt; Storage + Time Machine 板载网卡 Realtek ALC1220 板载网卡 Intel I219V2 PCI Express Gigabit Ethernet 无线网卡&amp;蓝牙 淘宝免驱BCM943602CS 必备软件 镜像 macOS Big Sur 11.0.1 20B50 Installer 工具 优盘镜像写入工具：Etcher OpenCore配置编辑器：OpenCore Configurator Changelog version 2.18.0.2 实用工具：Hackintool Releases List 调解显示器HIDPI：resxtreme 自用OpenCore配置 注意：请自行通过OpenCore Configurator生成序列号 链接: https://pan.baidu.com/s/1Qrq_GnG3mN2QRecT0ZZTEg 密码: 7u3j BIOS设置 BIOS版本升级到了F14，需要解锁CFG LOCK，详见🔗 Save &amp; Exit → Load Optimized Defaults M.I.T. → Advanced Memory Settings Extreme Memory Profile(X.M.P.) : Profile 1 BIOS → Fast Boot : Disabled BIOS → CMS Support: Disabled BIOS → LAN PXE Boot Option ROM : Disabled Peripherals → Super IO Configuration → Serial Port : Disabled Peripherals → USB Configuration → XHCI Hand-off : Enabled Chipset → Vt-d : Disabled 截图 遇到的问题 访达硬盘图标显示异常：发现是访达拓展兼容问题，偏好设置-&gt; 拓展 -&gt; “访达”拓展 取消勾选可疑的拓展，重启访达就好 唤醒后隔空投送自动关闭：平时不常用隔空投送，暂时先这样，不影响正常使用 参考链接 Gigabyte Z370 HD3P - i7 8700K - RX580 8GB - Catalina 10.15.5 - OpenCore 0.5.9 技嘉Z370-HD3P和i7-8700的OC0.5.6配置，媲美白苹果","link":"/gigabyte-z370-hd3p-opencore-efi-share/"},{"title":"n3540软路由安装pve+ikuai+openwrt(lede)双软路由系统记录","text":"爱快+OpenWrt是目前比较流行的双软路由方案。我具体方案是：1.爱快作为拨号和控流、Nas外网映射；2.Lede插件市场丰富作为旁路由，来解决404网站访问，广告屏蔽；3.网件路由器作为中继AP接管有线设备、WiFi设备的网络接入。 硬件设备 某宝N3540软路由+4G内存条+64G SSD NETGEAR 6800 群辉 DS220+ 软件工具 PVE镜像：https://pve.proxmox.com/wiki/Main_Page iKuai固件：https://www.ikuai8.com/component/download HomeLede固件：https://github.com/xiaoqingfengATGH/HomeLede/wiki 选择使用HomeLede，而不是自行编译的原因是：HomeLede内置内置了科学工具、AdGuard、DNS等刚需解决方案，就懒得自己去折腾了。 功能需求 科学访问：电脑、手机等设备能够无限访问外网 广告拦截：多设备上对去除广告，禁止用户追踪，防止DNS污染 NAS外网映射：利用DDNS将NAS的应用端口映射到外网，可以远程访问和管控 网络共享：内网设备之间能够网络共享，备份Mac Time Machine到NAS中 网络拓扑具体如何在软路由上安装PVE以及iKuai、Lede这里就不详细给出了，网上相关的文章已经很多了，自己根据自己需求搜索相关教程即可，下面是根据我设备和需求情况画出的网络拓补图：","link":"/pve-ikuai-lede-install/"},{"title":"【读书笔记】The Grammar of Graphics - 1. Introduction","text":"《The Grammar of Graphics》是作者Leland Wilkinson在开发GPL过程中，所沉淀的一本关于图形语法学的著作。号称是很多流行图表库（例如：G2、Vega、ggplot2）的理论基础，希望自己能坚持读完，也能在其中有所收获。 “语法”一词的英文“Grammar”来自古希腊语γραμματικὴ τέχνη（grammatikē technē），意思是“字母的艺术”。语法给出语言的规则，是一套“体系内元素的组合规则”，用于生成语言中的合法陈述。 在图表分类理论中，我们知道有柱状图、折线图、饼图、散点图等这些图表，但是现实生活中是不是只有这些图表呢？当然不是，随着计算机的普及和图形学的发展，统计需求得到进一步的丰富和发展。新的可视化图表层出不穷的出现，如：雷达图、桑吉图、K线图等，如果以传统的分类方式去枚举实现各种图表，将会是个巨大且难以维护和复用的工作。 那么问题来了，如何以比较小的代价尽可能多的穷举图形呢？ 通过分析现象看到本质，其实这个问题总的来说就是：如何可视化来表达图表的问题，作者通过对各种图表进行研究和分析后，一套语法描述图形的理论诞生了，编写基于图形语法的软件包有了理论依据和设计实践指导。 1.1 图形 VS 图表我们经常称统计图为“某某图”或者“Chart”，例如饼图(pie chart)、条形图(bar chart)、折线图(line chart)等。在图形语法学中，我们应该避免探讨图表分类，图形和图表的区别在于图形是比图表更基本的视觉元素。一旦我们理解，饼图其实是堆叠条形图在极坐标的呈现，我们就能在极坐标下构建更多鲜为人知的图形。 如果我们是在埋头开发某个类型图表，而不是制图程序，我们将面临两个问题： 我们不可避免无法满足人们所有的图表可视化需求，因为人们的需求是在不断变化的，我们无法马上去开发和提供大家想要的图表 我们可能无法复用不同图表的代码和设计 我们需要思考抽象构成构成图表的基础元素，我们需要考虑图形理论，而不是在纠结具体的某个图表。很多BI产品和图表库只提供一些固定的图表类型选择，这样有利于用户使用和理解，同时给用户提供了便利，但是对我们深入理解图形没有参考价值。 1.2 面向对象设计本书很多见解都受到了面向对象设计的启发，在大学课程中我们就学习过面向对象编程了，这里不做过多的阐述了，知乎有个话题：如何通俗易懂地举例说明「面向对象」和「面向过程」有什么区别？ 解释的挺通俗易懂。 1.3 一个面向对象的图形系统在数学中，图(graph) 是代表了满足公式的点的集合，它是不可见的。在物理中，图形(graphic) 是图(graph)的物理呈现，这就使得图形需要大小、颜​​色等美学属性来呈现的。 在一个面向对象系统中，图形通常是一个对象，但它本身具有位置、颜色、坐标等对象的属性，这使得该图形系统具有通用性，但这只是基于一些简单的对象和规则，下面将继续揭示这种系统的丰富性。 图形创作的三个阶段：• 规格（Specification）• 装配（Assembly）• 展示（Display） Specification这里 Specification 可以理解为描述图形属性的规格描述，用户可能不需要知道这些规则，但是制图系统需要理解和遵循这些规则、语法。 统计图形的规格描述可以用以下六个语句表示： DATA: 数据可视化基于的数据源 TRANS: 对数据的一些转化操作，如聚合、排序、筛选等 SCALE: 缩放操作，如log COORD: 坐标系统，如极坐标系、直角坐标系 ELEMENT: 图形的视觉元素与属性，如颜色、大小、形状 GUIDE: 提示信息，如刻度、图例 Assembly一个场景画面和它的规格描述还是有很大不同的。为了依据规格描述绘制出画面，我们必须要处理它的几何、布局、美学属性等等来使它的场景被精准地渲染出来。一个统计图的制图系统和体系必须要能够从一份规格说明装配成一幅真正的图表。 Display为了让我们感知图形，需要将图形渲染在某一种介质上，例如：显示器、报纸，视频等。除了基本的绘图功能外，我们还可能需要实现刷新、下钻、上卷、缩放等复杂的交互 1.4 举个例子 下面来实际使用图形创作的三个阶段： Specification 12345678ELEMENT: point(position(birth*death), size(0), label(country))ELEMENT: contour(position( smooth.density.kernel.epanechnikov.joint(birth*death)), color.hue())GUIDE: form.line(position((0,0),(30,30)), label(&quot;Zero Population Growth&quot;))GUIDE: axis(dim(1), label(&quot;Birth Rate&quot;))GUIDE: axis(dim(2), label(&quot;Death Rate&quot;)) 上面的规格描述仅使用到了ELEMENT和GUIDE组件，那么DATA、TRANS、SCALE、COORD都为默认没有操作，坐标系为笛卡尔坐标系。 第一个ELEMENT：表示为一个点，这个点的位置由birth*death决定，这个点不实际显示，因为的size大小为0，label内容为国家名称 第二个ELEMENT：表示等高线图，用来代表不同区域中国家的密度。彼此靠近的国家越多，密度等值线就越高。 第一个GUIDE：表示零人口增长线，辅助线左边的国家人口趋向下降，辅助线右边的国家人口趋向增长 接下来的两个GUIDE分别用来表示出生率、死亡率的轴、以及刻度、轴名称 参考链接 Antv: 数据可视化图形语法简史 图之典 正经可视化: 第一章 图形语法学简介 [The Grammar of Graphics 笔记] 1.介绍","link":"/the-grammar-of-graphics-chapter1/"},{"title":"ZRender设计思路分析","text":"ZRender是一个轻量级的Canvas类库，EChart就是在ZRender基础上建立的，给ECharts提供2D绘制能力。我平时的工作是负责BI系统的开发，需要用到图表库进行可视化展示，借此机会来更加深入了解平时用到的工具其底层原理。 简介ZRender 是二维绘图引擎，它提供 Canvas、SVG、VML 多种渲染方式。ZRender 也是 ECharts 的渲染器。注意：文章的分析是基于ZRender 5.x版本进行。 文档官网：https://ecomfe.github.io/zrender-doc/public/ GitHub主页：https://github.com/ecomfe/zrender Canvas API Doc：https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API SVG API Doc：https://developer.mozilla.org/zh-CN/docs/Web/SVG Hello World初始化 ZRender在使用 ZRender 前需要初始化实例，具体方式是传入一个 DOM 容器： 12import zrender from &quot;zrender&quot;;const zr = zrender.init(document.getElementById('main')); 创建出的这个实例对应文档中 zrender 实例部分的方法和属性。 在场景中添加元素ZRender 提供了将近 20 种图形类型，可以在文档 zrender.Displayable 下找到。如果想创建其他图形，也可以通过 zrender.Path.extend 进行扩展。 以创建一个圆为例： 12345678910111213const circle = new zrender.Circle({ shape: { cx: 50, cy: 50, r: 40 }, style: { fill: &quot;none&quot;, stroke: &quot;#F00&quot; }});zr.add(circle); 创建了一个圆心在 [50, 50] 位置，半径为 40 像素的圆，并将其添加到画布中。 修改图形元素属性通过 a = new zrender.XXX 方法创建了图形元素之后，可以用 a.shape 等形式获取到创建时输入的属性，但是如果需要对其进行修改，应该使用 a.attr(key, value) 的形式修改，否则不会触发图形的重绘。例子： 123circle.attr(&quot;shape&quot;, { r: 50 // 只更新半径大小}); DEMO 目录介绍12345678910111213141516171819src├─ animation # 动画操作相关├─ contain # 是否包含判断utils├─ core # 核心业务逻辑├─ dom # dom事件处理├─ graphic # 各种图形的实体，图形实体，分而治之的图形策略，可定义扩展├─ mixin # 需要进行混入的utils├─ canvas # Canvas操作封装├─ svg # SVG操作封装├─ vml # VML操作封装，VML是早期IE浏览器绘制矢量图形的语言，后被SVG替代├─ tool # 绘画拓展工具├─ Element.ts # ZRender中最基础的元素├─ Handler.ts # Controller层，控制层，事件交互处理，实现dom元素的模拟封装├─ Painter.ts # View层，视图层，元素生命周期管理，视图渲染，绘制和更新控制├─ Storage.ts # Model层，shape数据管理层├─ Layer.ts # 图层管理├─ config.ts # 配置信息├─ export.ts # 导出└─ zrender.ts # 入口 设计思想总的来说，MVC核心封装实现图形存储、视图渲染和交互控制： Stroage(M) : shape数据CURD管理 Painter(V) : canvase元素生命周期管理，视图渲染，绘画，更新控制 Handler(C) : 事件交互处理，实现完整dom事件模拟封装 shape : 图形实体，分而治之的图形策略，可定义扩展 tool : 绘画扩展相关实用方法，工具及脚手架 入口分析 ⤵️我们可以从package.json的main字段或者build/build.js构建文件了解到，ZRender的入口文件在/index.ts中： 123456export * from './src/zrender';export * from './src/export';import './src/canvas/canvas';import './src/svg/svg';// import './src/vml/vml'; // 5.x注释了对IE VML的支持 上述的两个export语句，是用来初始化ZRender，那么ZRender到底是什么，它是如何工作的，我们来一探究竟吧。 ZRender的入口通过上面的分析，具体ZRender的入口是：src/zrender.ts，我们先具体看下这的实现逻辑： src/zrender.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748let instances: { [key: number]: ZRender } = {};function delInstance(id: number) { delete instances[id];}class ZRender { ... }/** * Initializing a zrender instance*/export function init(dom: HTMLElement, opts?: ZRenderInitOpt) { const zr = new ZRender(zrUtil.guid(), dom, opts); instances[zr.id] = zr; return zr;}/** * Dispose zrender instance */export function dispose(zr: ZRender) { zr.dispose();}/** * Dispose all zrender instances */export function disposeAll() { for (let key in instances) { if (instances.hasOwnProperty(key)) { instances[key].dispose(); } } instances = {};}/** * Get zrender instance by id */export function getInstance(id: number): ZRender { return instances[id];}export function registerPainter(name: string, Ctor: PainterBaseCtor) { painterCtors[name] = Ctor;}export const version = '5.0.1'; 这里的关键部分有: class ZRender {...}: ZRender类，后续再展开分析 init(): 初始化ZRender实例，并以key-value的形式存储到instances对象中 dispose(): 销毁 ZRender 实例 disposeAll(): 销毁instances中所有的ZRender实例 getInstance()、delInstance(): 获取or删除instances中的实例 registerPainter(): 注册Canvas、SVG视图层逻辑 ZRender的export除了上面的src/zrender.ts模块，入口文件还导出了src/exports，具体的代码如下： src/exports.ts >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Do not mount those modules on 'src/zrender' for better tree shaking. */import * as zrUtil from './core/util';import * as matrix from './core/matrix';import * as vector from './core/vector';import * as colorTool from './tool/color';import * as pathTool from './tool/path';import {parseSVG} from './tool/parseSVG';import {morphPath} from './tool/morphPath';export {default as Point} from './core/Point';export {default as Element} from './Element';export {default as Group} from './graphic/Group';export {default as Path} from './graphic/Path';export {default as Image} from './graphic/Image';export {default as CompoundPath} from './graphic/CompoundPath';export {default as TSpan} from './graphic/TSpan';export {default as IncrementalDisplayable} from './graphic/IncrementalDisplayable';export {default as Text} from './graphic/Text';export {default as Arc} from './graphic/shape/Arc';export {default as BezierCurve} from './graphic/shape/BezierCurve';export {default as Circle} from './graphic/shape/Circle';export {default as Droplet} from './graphic/shape/Droplet';export {default as Ellipse} from './graphic/shape/Ellipse';export {default as Heart} from './graphic/shape/Heart';export {default as Isogon} from './graphic/shape/Isogon';export {default as Line} from './graphic/shape/Line';export {default as Polygon} from './graphic/shape/Polygon';export {default as Polyline} from './graphic/shape/Polyline';export {default as Rect} from './graphic/shape/Rect';export {default as Ring} from './graphic/shape/Ring';export {default as Rose} from './graphic/shape/Rose';export {default as Sector} from './graphic/shape/Sector';export {default as Star} from './graphic/shape/Star';export {default as Trochoid} from './graphic/shape/Trochoid';export {default as LinearGradient} from './graphic/LinearGradient';export {default as RadialGradient} from './graphic/RadialGradient';export {default as Pattern} from './graphic/Pattern';export {default as BoundingRect} from './core/BoundingRect';export {default as OrientedBoundingRect} from './core/OrientedBoundingRect';export {matrix};export {vector};export {colorTool as color};export {pathTool as path};export {zrUtil as util};export {parseSVG};export {morphPath};export {default as showDebugDirtyRect} from './debug/showDebugDirtyRect'; 可以看到，export.ts的职责是用来导出模块到外部。其中包括core、tool中的工具函数方法，以及ZRender抽象出来的各种shape图形模块，方便以zrender.xx方式进行调用。 另外，模块的第一行注释写到：Do not mount those modules on ‘src/zrender’ for better tree shaking，相比在src/zrender.ts中一股脑进行导出和调用，export.ts导出的都是无副作用的函数，更加有利于构建工具对代码进行静态分析进行Tree Shaking，避免ECharts使用ZRender时，打包了未实际使用的代码。 Painter画笔注册注册前期基本工作已经介绍完了，ZRender是如何将图形绘制出来的呢？其实现在前端主流的2D绘制方式有两种：Canvas和SVG，那么ZRender就需要分别封装Canvas和SVG各自的API，来抹平不同绘制方式在使用时候的差异： 导入画笔 index.ts123456export * from './src/zrender';...import './src/canvas/canvas';import './src/svg/svg';// import './src/vml/vml'; 注册Canvas画笔 src/canvas/canvas.ts12345import './graphic';import {registerPainter} from '../zrender';import Painter from './Painter';registerPainter('canvas', Painter); 注册SVG画笔 src/svg/svg.ts12345import './graphic';import {registerPainter} from '../zrender';import Painter from './Painter';registerPainter('svg', Painter); 上面👆代码的主要作用是：在初始化执行完zrender后，调用registerPainter()方法来把画笔🖌注册到全局的zrender中，其中： graphic模块: 封装形状、图片、文本…绘制函数 Painter模块: 提供给zrender进行图形绘制 VML可以看到5.x版本注释了VML(Vector Markup Language)画笔，不了解VML的可以将VML理解为SVG的祖先，用于兼容低版本IE浏览器。VML维基百科定义： Vector Markup Language（VML）是一种XML语言用于绘制矢量图形（vector graphics）。1998年VML建议书由微软、Macromedia等向W3C提出审核。VML遭到拒绝，因为Adobe、Sun等提出了PGML[1]计划书。这两套标准后来合并成更具潜力的SVG。 new ZRender在干嘛 🧩介绍我们之前提到的初始化 ZRender中，初始化一个ZRender实例并没有到new语句，其实是在init()中执行的class ZRender，然后供给导出外部调用，代码如下： src/zrender.ts12345export function init(dom: HTMLElement, opts?: ZRenderInitOpt) { const zr = new ZRender(zrUtil.guid(), dom, opts); instances[zr.id] = zr; return zr;} 给new ZRender分类因为class ZRender内的逻辑较多，下面代码用注释将类似功能分隔开来，这样能够看起来更加清晰。可以看到，其实zrender实例包含了以下三大功能，同时也和MVC分层对应： 图形存储层 管理存储画布内的元素，对应Storage相关的逻辑，提供对Element的增删查改操作 视图绘制层 Painter绘制图形元素，创建和修改DOM元素，进行refresh、flush等绘制操作 逻辑控制层 Handler负责click、mouse、hover等事件的处理 src/zrender.ts >folded123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class ZRender { id: number // unique id dom: HTMLElement // zrender容器dom storage: Storage // mvc model painter: PainterBase // mvc view handler: Handler // mvc control animation: Animation // 动画 TODO:学习 ... constructor(id: number, dom: HTMLElement, opts?: ZRenderInitOpt) {...} // ============= 图形存储相关 ============= add(el: Element) {...} remove(el: Element) {...} // ============= TODO: 待学习 ============= configLayer(zLevel: number, config: LayerConfig) {...} // ============= 背景颜色相关 ============= private _backgroundColor: string | GradientObject | PatternObject; --&gt; setBackgroundColor(backgroundColor: string | GradientObject | PatternObject) {...} getBackgroundColor() {...} // ============= 暗黑模式相关 ============= setDarkMode(darkMode: boolean) {...} isDarkMode() {...} // ============= 刷新绘制相关 ============= refreshImmediately(fromInside?: boolean) {...} refresh() {...} flush() {...} private _flush(fromInside?: boolean) {...} setSleepAfterStill(stillFramesCount: number) {...} wakeUp() {...} refreshHover() {...} refreshHoverImmediately() {...} clearAnimation() {...} // ============= DOM容器相关 ============= resize(opts?: { width?: number| string height?: number | string }) {...} getWidth(): number {...} getHeight(): number {...} // ============= 其他 ============= pathToImage(e: Path, dpr: number) {...} setCursorStyle(cursorStyle: string) {...} findHover(x: number, y: number): { target: Displayable, topTarget: Displayable } {...} // ============= 自定义事件相关 ============= on&lt;Ctx&gt;(eventName: eventHandler: , context?: Ctx): this {...} off(eventName?: string, eventHandler?: EventCallback&lt;unknown, unknown&gt;) {...} trigger(eventName: string, event?: unknown) {...} // ============= 卸载、清理相关 ============= clear() {...} dispose() {...}} Storage分析 🗂️Storage对应MVC层中的Model，即数据的保存，，具体接口类定义如下： src/Storage.ts12345678export default class Storage { private _roots: Element[] = [] private _displayList: Displayable[] = [] private _displayListLen = 0} _roots Element[]：存储zrender.add(Element)添加进来的元素 _displayList: Displayable[]：存储可显示的元素(继承自Displayable的元素)，提供给Painter进行渲染 Storage接口类的其他部分逻辑都是是对上面两个数组的增删查改的封装，方便给其他模块调用而已。 参考链接 InfoQ: 可视化了解一下？ ECharts 4.0最全技术攻略 FunDeug: 配置Tree Shaking来减少JavaScript的打包体积","link":"/zrender-source-code/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"黑苹果","slug":"黑苹果","link":"/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"},{"name":"OpenWrt","slug":"OpenWrt","link":"/tags/OpenWrt/"},{"name":"Lede","slug":"Lede","link":"/tags/Lede/"},{"name":"iKuai","slug":"iKuai","link":"/tags/iKuai/"},{"name":"图形语法学","slug":"图形语法学","link":"/tags/%E5%9B%BE%E5%BD%A2%E8%AF%AD%E6%B3%95%E5%AD%A6/"},{"name":"Canvas","slug":"Canvas","link":"/tags/Canvas/"},{"name":"SVG","slug":"SVG","link":"/tags/SVG/"},{"name":"ZRender","slug":"ZRender","link":"/tags/ZRender/"},{"name":"ECharts","slug":"ECharts","link":"/tags/ECharts/"}],"categories":[{"name":"笔记本","slug":"笔记本","link":"/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"},{"name":"黑苹果","slug":"黑苹果","link":"/categories/%E9%BB%91%E8%8B%B9%E6%9E%9C/"},{"name":"软路由","slug":"软路由","link":"/categories/%E8%BD%AF%E8%B7%AF%E7%94%B1/"},{"name":"可视化","slug":"可视化","link":"/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"图形语法学","slug":"可视化/图形语法学","link":"/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/%E5%9B%BE%E5%BD%A2%E8%AF%AD%E6%B3%95%E5%AD%A6/"},{"name":"ZRender","slug":"可视化/ZRender","link":"/categories/%E5%8F%AF%E8%A7%86%E5%8C%96/ZRender/"}]}